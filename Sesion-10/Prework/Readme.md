ğŸ  [**Inicio**](../../Readme.md) â¡ï¸ / ğŸ“– `Prework sesiÃ³n 10`

<div align="center">
    <img src="../Imagenes/S10.jpg" alt="Bedu | Haz + con tu talento | JAVA STANDARD EDITION II">
</div>

##### **PREWORK**
#### **ğŸŸ§ SesiÃ³n 10**
#### **Mentorship 2**

##### ğŸ”¶ **IntroducciÃ³n** 

Â¡Bienvenidos a la Ãºltima sesiÃ³n del mÃ³dulo Java Standard Edition! En esta sesiÃ³n especial, haremos un recorrido integral por todos los temas clave que hemos trabajado a lo largo de las nueve sesiones anteriores.

Durante este tiempo, exploraste desde los fundamentos del lenguaje Java hasta conceptos avanzados de programaciÃ³n orientada a objetos, estructuras de datos, manejo de archivos, colecciones, herencia, buenas prÃ¡cticas y manejo de errores. Ahora es momento de consolidar lo aprendido, repasar los puntos mÃ¡s importantes y aclarar cualquier duda pendiente.

Esta sesiÃ³n estÃ¡ diseÃ±ada como un espacio de repaso y reflexiÃ³n, donde podrÃ¡s hacer conexiones entre los distintos temas, revisar conceptos esenciales y prepararte para afrontar futuros proyectos con una base sÃ³lida en Java.

---

#### ğŸ¯ Objetivo  

- Consolidar los conocimientos adquiridos durante el mÃ³dulo Java Standard Edition, repasando los conceptos clave de cada sesiÃ³n: desde la sintaxis bÃ¡sica de Java y la POO, hasta el manejo de colecciones, archivos y buenas prÃ¡cticas de desarrollo.
- Aclarar dudas y fortalecer la comprensiÃ³n sobre temas fundamentales como clases, objetos, herencia, polimorfismo, colecciones, excepciones, estructuras de control, manejo de archivos y principios SOLID.
- Preparar al estudiante para aplicar estos conocimientos en proyectos reales o en etapas avanzadas de formaciÃ³n, fomentando la confianza, la claridad y el pensamiento estructurado en el desarrollo con Java.
---

#### ğŸ“‹ Instrucciones

Este Prework estÃ¡ diseÃ±ado para conocer el contenido que se practicarÃ¡ durante la sesiÃ³n en vivo. **Por favor no lo omitas**. Toma notas de lo que consideres relevante y guarda tus preguntas o dudas para resolverlas en la sesiÃ³n.

---

#### Bienvenido/a

Bienvenid@ al decimo Prework del mÃ³dulo. A continuaciÃ³n, te presentamos el tiempo estimado de lectura por tema, para que puedas revisar todos los recursos al mÃ¡ximo:

| **ğŸ“– Temario**                       | **ğŸ•°ï¸ Tiempo sugerido** |
|--------------------------------------|-------------------------|
| Tema 01. Repaso integral del modulo  | 15 min                  |

**Â¡Comencemos! ğŸ**

---
Â 
#### ğŸ“š Tema 01. Repaso integral del modulo
##### â³ 15 minutos de lectura.

A lo largo de estas nueve sesiones, has recorrido un camino de aprendizaje en el que desarrollaste habilidades esenciales para convertirte en un programador Java mÃ¡s sÃ³lido, estructurado y profesional. Este cÃ­rculo de estudio representa una excelente oportunidad para reflexionar sobre lo que has aprendido y fortalecer tu dominio del lenguaje.

En este repaso, destacaremos los conceptos clave y aprendizajes de cada sesiÃ³n, permitiÃ©ndote recordar, conectar ideas y reconocer el gran avance que has logrado en tu proceso de formaciÃ³n.

Â¡Vamos con todo para cerrar con claridad y confianza este mÃ³dulo! ğŸ’ªğŸš€

**SesiÃ³n 01. IntroducciÃ³n a la programaciÃ³n orientada a objetos en Java**

En esta primera sesiÃ³n dimos nuestros primeros pasos en el mundo de Java, un lenguaje de programaciÃ³n que ha marcado la industria por su robustez, portabilidad y enfoque en la ProgramaciÃ³n Orientada a Objetos (POO).

ğŸ§  Â¿QuÃ© aprendiste?
- Comprendiste que Java es un lenguaje:
    - Multiplataforma gracias a la Java Virtual Machine (JVM), que permite ejecutar un mismo programa en distintos sistemas operativos.
    - Orientado a objetos, lo que significa que todo en Java gira en torno a clases y objetos.
    - Seguro y estable, ideal para desarrollar aplicaciones empresariales, mÃ³viles, web y de escritorio.

ğŸ”§ PreparaciÃ³n del entorno
- Aprendiste a instalar y configurar las herramientas necesarias para desarrollar en Java:
    - Java Development Kit (JDK): el conjunto de herramientas que permite compilar y ejecutar programas Java.
    - IntelliJ IDEA Community Edition: un entorno de desarrollo profesional que facilita la escritura, navegaciÃ³n y depuraciÃ³n de cÃ³digo.

ğŸ’¡ IntroducciÃ³n al paradigma POO
- Ingresaste al paradigma que define la forma moderna de programar:
    - Clases: estructuras que representan entidades con atributos (datos) y mÃ©todos (acciones).
    - Objetos: instancias concretas de una clase.
    - Encapsulamiento: control de acceso a los datos para proteger la integridad del objeto.
    - Herencia: reutilizaciÃ³n de cÃ³digo mediante jerarquÃ­as entre clases.
    - Polimorfismo: posibilidad de que una misma operaciÃ³n tenga comportamientos distintos segÃºn el objeto que la ejecute.
    - AbstracciÃ³n: capacidad de representar solo lo esencial de una entidad, ocultando los detalles innecesarios.

ğŸ†• CaracterÃ­sticas modernas de Java
- Conociste nuevas caracterÃ­sticas del lenguaje introducidas en versiones recientes:
    - `record`: un tipo especial de clase para definir objetos inmutables de forma sencilla, ideal para modelos de datos.
    - `sealed classes`: permiten restringir quÃ© clases pueden heredar de una clase base, mejorando la seguridad y el control del diseÃ±o.

Esta sesiÃ³n sentÃ³ las bases conceptuales y tÃ©cnicas para el resto del curso. Fue el punto de partida para entender no solo cÃ³mo escribir cÃ³digo en Java, sino cÃ³mo **pensar en objetos**, estructurar soluciones escalables y adoptar buenas prÃ¡cticas desde el inicio.

**SesiÃ³n 02: Tipos de datos y sentencias de control**  

En esta sesiÃ³n, exploraste los fundamentos que permiten construir la lÃ³gica de cualquier programa en Java. Aprendiste a trabajar con datos, realizar operaciones y controlar el flujo de ejecuciÃ³n, habilidades clave para que tu cÃ³digo tome decisiones y repita tareas eficientemente.

ğŸ”  Tipos de datos y uso de `var`
- Comprendiste que en Java los tipos de datos primitivos son la base para almacenar informaciÃ³n:
    - `int`, `double`, `boolean`, `char`, entre otros.

- Aprendiste a declarar variables usando el tipo correspondiente, y tambiÃ©n a usar `var`, una palabra clave que permite que el compilador infiera el tipo automÃ¡ticamente:
    - Ideal para reducir redundancia, pero requiere que el valor inicial sea claro y legible.

ğŸ” ConversiÃ³n de tipos (casting)
- Estudiaste cÃ³mo convertir valores de un tipo a otro:
    - ConversiÃ³n implÃ­cita (de tipo menor a mayor): por ejemplo, `int â†’ long`.
    - ConversiÃ³n explÃ­cita (de tipo mayor a menor): por ejemplo, `double â†’ int`, con posible pÃ©rdida de informaciÃ³n.

â• Operadores y expresiones
- Dominar los operadores es esencial para crear condiciones y realizar cÃ¡lculos. Aprendiste a utilizar:
    - AritmÃ©ticos: `+`, `-`, `*`, `/`, `%`
    - Relacionales: `==`, `!=`, `<`, `>`, `<=`, `>=`
    - LÃ³gicos: `&&`, `||`, `!`
    - AsignaciÃ³n y combinaciÃ³n: `=`, `+=`, `-=`, etc.
    - Incremento/Decremento: `++`, `--`

- TambiÃ©n conociste el concepto de precedencia y cÃ³mo afecta el orden de evaluaciÃ³n en las expresiones complejas.

ğŸ”€ Estructuras de control condicional
- `if`, `else if`, `else`: estructuras bÃ¡sicas para tomar decisiones.

- IntroducciÃ³n a la nueva sintaxis de `switch` (Java 12+), que permite:
    - Mayor claridad con el uso de `->`
    - Asignaciones directas de valores
    - EliminaciÃ³n del uso obligatorio de `break`

ğŸ”„ Bucles y repeticiÃ³n
Aprendiste a repetir instrucciones usando diferentes estructuras:
- `for`: ideal cuando conoces el nÃºmero de iteraciones.
- `while`: se ejecuta mientras se cumpla una condiciÃ³n.
- `do-while`: garantiza al menos una ejecuciÃ³n.
- `for-each`: Ãºtil para recorrer colecciones sin manejar Ã­ndices directamente.

ğŸ§  Buenas prÃ¡cticas en estructuras de control
- Usa `if` y `switch` solo cuando sea necesario y evita anidar demasiadas condiciones.
- Emplea el bucle mÃ¡s adecuado para el problema que estÃ¡s resolviendo.
- Ten cuidado con los bucles infinitos y asegÃºrate de que la condiciÃ³n de salida sea clara.

Esta sesiÃ³n fue esencial para comenzar a escribir cÃ³digo **dinÃ¡mico, interactivo y con lÃ³gica propia**. Aprendiste que un buen manejo de datos y estructuras de control te permite tomar decisiones, validar condiciones, y ejecutar acciones repetitivas sin duplicar cÃ³digo.

**SesiÃ³n 03. Clases y objetos: crea aplicaciones que permitan el ingreso de informaciÃ³n**

Esta sesiÃ³n fue clave para profundizar en los pilares de la ProgramaciÃ³n Orientada a Objetos (POO). Aprendiste a crear tus propias clases, instanciar objetos y definir mÃ©todos para que estos objetos puedan ejecutar acciones especÃ­ficas. Todo esto representa el corazÃ³n del desarrollo en Java.

ğŸ§± Clases y objetos

- Clase: es una plantilla que define las caracterÃ­sticas (atributos) y comportamientos (mÃ©todos) de un tipo de objeto.
- Objeto: es una instancia de una clase, es decir, una versiÃ³n concreta que puede almacenar informaciÃ³n y ejecutar mÃ©todos.

ğŸ“Œ Ejemplo:

```java
class Perro {
    String nombre;
    void ladrar() {
        System.out.println("Â¡Guau!");
    }
}
```
```java
Perro miPerro = new Perro();
miPerro.nombre = "Max";
miPerro.ladrar();
```

ğŸ”§ Constructores
- Son mÃ©todos especiales que se ejecutan automÃ¡ticamente al crear un objeto.
- Pueden ser:
    - Por defecto (sin parÃ¡metros)
    - Con parÃ¡metros (para inicializar atributos directamente)
    - De copia (para duplicar objetos)
- Puedes tener mÃºltiples constructores usando sobrecarga, es decir, diferentes versiones con distintos parÃ¡metros.

âœï¸ MÃ©todos con parÃ¡metros y retorno
- Los mÃ©todos pueden recibir valores (parÃ¡metros) y tambiÃ©n devolver resultados:
    - MÃ©todos `void`: no devuelven nada, solo ejecutan acciones.
    - MÃ©todos con tipo de retorno (`int`, `String`, etc.): devuelven un valor que puede ser usado en otra parte del programa.

ğŸ“Œ Ejemplo:

```java
int sumar(int a, int b) {
    return a + b;
}
```
ğŸ›¡ï¸ Modificadores de acceso
- Permiten controlar la visibilidad de clases, atributos y mÃ©todos:
    - `public`: accesible desde cualquier lugar
    - `private`: solo accesible dentro de la misma clase
    - `protected`: accesible desde clases hijas o del mismo paquete

âœ… Esto refuerza el principio de encapsulamiento, protegiendo la informaciÃ³n sensible de un objeto.

ğŸ“¦ Palabras clave: `static` y `final`
- `static`: asocia un atributo o mÃ©todo a la clase, no a sus objetos. Ãštil para valores globales o mÃ©todos utilitarios.
- `final`: indica que una variable, clase o mÃ©todo no puede ser modificada ni sobrescrita. Se usa para crear constantes o proteger comportamientos.

â“ Â¿QuÃ© es `Optional`?
Es una clase que permite manejar valores nulos de forma segura y evitar errores como `NullPointerException`.
En vez de retornar `null`, puedes retornar un `Optional.empty()` o un `Optional.of(valor)`.

Esta sesiÃ³n te ayudÃ³ a dominar la estructura base de cualquier programa en Java. Aprendiste a **modelar el mundo real en cÃ³digo**, usando clases como planos, objetos como instancias reales, y mÃ©todos como acciones que estos objetos pueden realizar. TambiÃ©n comenzaste a aplicar buenas prÃ¡cticas de diseÃ±o, protecciÃ³n de datos y organizaciÃ³n del cÃ³digo.

**SesiÃ³n 04. Elementos de una clase: implementa validaciÃ³n de datos**  

En esta sesiÃ³n profundizaste en cÃ³mo estructurar correctamente una clase en Java, incluyendo no solo los atributos y mÃ©todos bÃ¡sicos, sino tambiÃ©n elementos especiales que hacen que tus clases sean mÃ¡s eficientes, legibles y seguras. Aprendiste a utilizar constructores, mÃ©todos especiales, encapsulaciÃ³n, inmutabilidad y herramientas modernas como `record` y `Objects.equals()`.  

ğŸ§± Constructores  
- Ya conocÃ­as su funciÃ³n, pero aquÃ­ los exploraste en detalle:
    - Constructor por defecto: no recibe parÃ¡metros y asigna valores predeterminados.
    - Constructor con parÃ¡metros: permite crear objetos con valores personalizados.
    - Constructor de copia: permite duplicar un objeto ya existente.

ğŸ’¡ TambiÃ©n aprendiste sobre la sobrecarga de constructores, es decir, tener mÃºltiples constructores con diferentes firmas en la misma clase.  

ğŸ” MÃ©todos especiales: `equals()`, `hashCode()` y `toString()`  
- Estos mÃ©todos permiten que tus objetos sean mÃ¡s Ãºtiles cuando los comparas, los imprimes o los almacenas en estructuras como mapas o conjuntos.  

| MÃ©todo       | Â¿Para quÃ© sirve?                                                                   |
|--------------|------------------------------------------------------------------------------------|
| `equals()`   | Compara si dos objetos son equivalentes por su contenido, no por referencia.       |
| `hashCode()` | Genera un cÃ³digo hash Ãºnico para almacenar el objeto en estructuras como `HashMap`.|
| `toString()` | Devuelve una representaciÃ³n de texto del objeto, Ãºtil para mostrarlo por consola.  |

âœ… Buena prÃ¡ctica: cuando sobrescribes `equals()`, tambiÃ©n debes sobrescribir `hashCode()` para evitar inconsistencias.  

ğŸ” `Objects.equals()`  
- Alternativa mÃ¡s segura a `equals()`, ya que permite comparar objetos incluso si alguno es null, evitando errores.

ğŸ“Œ Ejemplo:  

```java
Objects.equals(obj1, obj2); // No lanza NullPointerException
```

ğŸ“¦ `record`: clases inmutables simplificadas
- Una forma moderna y concisa de crear clases que solo almacenan datos.
- Java genera automÃ¡ticamente el constructor, `equals()`, `hashCode()` y `toString()`.

ğŸ“Œ Ejemplo:

```java
record Usuario(String nombre, int edad) {}
```

âœ… Ideal para modelos de datos, DTOs o cualquier clase que solo requiera almacenar informaciÃ³n.  

ğŸ”’ EncapsulaciÃ³n e inmutabilidad  
- EncapsulaciÃ³n: proteger los datos de una clase usando modificadores de acceso y mÃ©todos `get` y `set`.
- Inmutabilidad: crear objetos cuyos valores no cambian una vez creados. Se logra usando:
    - Atributos `private final`
    - Sin `setters`
    - InicializaciÃ³n por constructor

ğŸ’¡ Ventajas  
- Protege la integridad del objeto.
- Evita errores inesperados en ejecuciÃ³n.
- Facilita la programaciÃ³n concurrente.

Esta sesiÃ³n te mostrÃ³ cÃ³mo **construir clases sÃ³lidas, seguras y profesionales**, cuidando los detalles de diseÃ±o que marcan la diferencia entre un cÃ³digo funcional y un cÃ³digo de calidad. TambiÃ©n aprendiste herramientas modernas de Java que reducen el cÃ³digo repetitivo y aumentan la legibilidad.

**SesiÃ³n 05. DiseÃ±o de clases (herencia y polimorfismo): reutiliza cÃ³digo existente por medio de herencia y polimorfismo**  

En esta sesiÃ³n diste un gran paso en el dominio de la ProgramaciÃ³n Orientada a Objetos (POO), aprendiendo a estructurar clases de forma mÃ¡s eficiente y flexible. Estudiaste tres pilares fundamentales para crear cÃ³digo *reutilizable, escalable y limpio: herencia, composiciÃ³n y polimorfismo*.

**ğŸ§¬ Herencia**  
- Es el mecanismo que permite a una clase (subclase) heredar atributos y mÃ©todos de otra clase (superclase).
- Se implementa usando la palabra clave `extends`.
- Aporta reutilizaciÃ³n de cÃ³digo, jerarquÃ­a lÃ³gica y menos duplicaciÃ³n.

ğŸ“Œ Ejemplo:  

```java
class Animal {
    void hacerSonido() { System.out.println("Sonido genÃ©rico"); }
}

class Perro extends Animal {
    @Override
    void hacerSonido() { System.out.println("Ladrido"); }
}
```

âœ… Ventajas  
- Permite centralizar comportamientos comunes.
- Facilita la extensiÃ³n de funcionalidades.

ğŸ§© ComposiciÃ³n  
- En lugar de heredar, una clase puede "tener" otras clases como atributos. Es decir, se construyen objetos mÃ¡s complejos a partir de otros.
- Favorece un diseÃ±o mÃ¡s modular y flexible.
- Es preferida sobre la herencia cuando no existe una clara relaciÃ³n "es un".

ğŸ“Œ Ejemplo:

```java
class Motor {
    void encender() { System.out.println("Motor encendido"); }
}

class Coche {
    private Motor motor = new Motor();
    void arrancar() {
        motor.encender();
        System.out.println("Coche en movimiento");
    }
}
```
ğŸ’¡ Regla de oro: Usa composiciÃ³n en relaciones "tiene un" y herencia solo cuando realmente hay una relaciÃ³n "es un".  

ğŸ§  Interfaces y clases abstractas
- Clases abstractas: no se pueden instanciar. Pueden contener mÃ©todos concretos y abstractos. Se heredan con `extends`.
- Interfaces: definen un contrato de mÃ©todos que una clase debe implementar. Se implementan con `implements`.  

âœ… Las interfaces permiten simular herencia mÃºltiple y mejorar la organizaciÃ³n del cÃ³digo cuando hay funcionalidades comunes en clases no relacionadas.  

ğŸ“Œ Ejemplo:

```java
interface Transportador {
    void transportarPasajeros();
}
```

ğŸ” Polimorfismo
- Significa que un mismo mÃ©todo puede comportarse de manera diferente segÃºn el objeto que lo ejecute.
- Se implementa mediante la sobrescritura de mÃ©todos (`@Override`).

ğŸ“Œ Ejemplo:

```java
Animal miAnimal = new Perro();
miAnimal.hacerSonido(); // Imprime: "Ladrido"
```

âœ… El polimorfismo permite escribir cÃ³digo genÃ©rico, donde la lÃ³gica se adapta al tipo real del objeto en tiempo de ejecuciÃ³n.  

Esta sesiÃ³n te enseÃ±Ã³ a **estructurar mejor tus programas**: usar herencia para aprovechar cÃ³digo existente, composiciÃ³n para diseÃ±ar sistemas modulares y polimorfismo para lograr flexibilidad. Aprendiste que escribir buen cÃ³digo no es solo **hacerlo funcionar, sino tambiÃ©n hacerlo extensible, organizado y mantenible**.

**SesiÃ³n 06. Colecciones: utiliza diversas estructuras de datos de acuerdo al tipo de aplicaciÃ³n a desarrollar**

En esta sesiÃ³n aprendiste a trabajar con *estructuras de datos dinÃ¡micas* en Java, fundamentales para manipular conjuntos de informaciÃ³n de forma ordenada, eficiente y flexible. Descubriste cÃ³mo usar colecciones como *listas, conjuntos y mapas*, cuÃ¡ndo aplicarlas, y cÃ³mo ordenarlas segÃºn distintas necesidades.

ğŸ“¦ Â¿QuÃ© son las colecciones?  
- Son estructuras que permiten agrupar y manejar mÃºltiples datos como una sola unidad.
- Sustituyen a los arreglos cuando necesitas mayor flexibilidad (tamaÃ±o variable, operaciones de bÃºsqueda, ordenamiento, etc.).

ğŸ”° Tipos principales de colecciones

| ColecciÃ³n | Permite duplicados   | Mantiene orden       | Clave-Valor | Uso tÃ­pico                         |
|-----------|----------------------|----------------------|-------------|------------------------------------|
| `List`    | âœ… SÃ­                | âœ… SÃ­               | âŒ No       | Lista de tareas, productos, etc.   |
| `Set`     | âŒ No                | âŒ No               | âŒ No       | Conjuntos Ãºnicos (como correos)    |
| `Map`     | âœ… (en valores)      | âš ï¸ Depende del tipo | âœ… SÃ­       | Diccionario, ID â†’ nombre           |


ğŸ§° Estructuras comunes  
- `ArrayList`: lista ordenada que permite duplicados y acceso por Ã­ndice.
- `HashSet`: conjunto sin duplicados, sin garantÃ­a de orden.
- `HashMap`: permite almacenar pares clave â†’ valor, con claves Ãºnicas.

ğŸ“Œ Ejemplos:

```java
ArrayList<String> nombres = new ArrayList<>();
HashSet<String> correos = new HashSet<>();
HashMap<Integer, String> empleados = new HashMap<>();
```

ğŸ”¢ Ordenamiento de colecciones
- Aprendiste dos formas de ordenar objetos, la primera:
    1. `Comparable` (orden natural):
        - Se implementa en la clase.
        - Solo permite un criterio de orden.

```java
class Producto implements Comparable<Producto> {
    public int compareTo(Producto otro) {
        return this.precio - otro.precio;
    }
}
```
- La segunda:

    2. `Comparator` (orden personalizado):
        - Se define fuera de la clase.
        - Permite mÃºltiples criterios.

âœ… Esto te permite organizar listas por precio, nombre, fecha, etc., segÃºn la necesidad.

ğŸ¤¯ Colecciones concurrentes
DiseÃ±adas para trabajo en mÃºltiples hilos (multithreading).
Evitan errores al acceder a colecciones desde distintos procesos simultÃ¡neamente.

Ejemplos:
- `CopyOnWriteArrayList`
- `ConcurrentHashMap`

ğŸ’¡ Ãštiles en aplicaciones con mÃºltiples usuarios o tareas que ocurren al mismo tiempo.

En resumen, esta sesiÃ³n te permitiÃ³ dominar las **estructuras dinÃ¡micas mÃ¡s usadas en Java**, eligiendo la colecciÃ³n adecuada segÃºn si necesitas orden, unicidad o asociaciÃ³n clave-valor. TambiÃ©n aprendiste a aplicar ordenamientos avanzados y preparar tus programas para trabajar en entornos concurrentes.

**SesiÃ³n 07. Manejo de archivos: guarda informaciÃ³n en un archivo de manera persistente**

En esta sesiÃ³n aprendiste a *leer, escribir, copiar y mover archivos* en Java de forma moderna, eficiente y segura usando la API NIO.2 (`java.nio.file`). Esta herramienta es esencial para desarrollar aplicaciones que interactÃºan con el sistema de archivos, como editores, cargadores de datos, reportes, logs y mÃ¡s.

ğŸ“‚ Â¿QuÃ© es NIO.2? 

- Introducida en Java 7, mejora la antigua API de archivos (`java.io`) ofreciendo:
    - Mayor flexibilidad
    - Mejor rendimiento
    - Soporte para operaciones concurrentes
    - Manejo claro de rutas y excepciones

ğŸ§° Clases clave de NIO.2

| Clase                    | Â¿Para quÃ© sirve?                                                      |
|--------------------------|-----------------------------------------------------------------------|
| `Path`                   | Representa una ruta de archivo o directorio                           |
| `Files`                  | Contiene mÃ©todos estÃ¡ticos para operar sobre archivos y directorios   |
| `FileSystems`            | Permite acceder al sistema de archivos                                |
| `StandardWatchEventKinds`| Permite observar cambios en archivos/directorios                      |

ğŸ“– Lectura y escritura de archivos

- `Files.readString()`: lee el contenido completo de un archivo como texto.
- `Files.write()`: escribe texto o datos binarios en un archivo.

ğŸ“Œ Ejemplo:

```java
Path ruta = Path.of("notas.txt");
String contenido = Files.readString(ruta);
Files.write(ruta, "Nueva nota".getBytes());
```

ğŸ” Copiar y mover archivos  
- `Files.copy(origen, destino)`: duplica un archivo.
- `Files.move(origen, destino)`: mueve o renombra un archivo.
TambiÃ©n puedes combinarlo con opciones como `StandardCopyOption.REPLACE\_EXISTING`.

ğŸ§­ VerificaciÃ³n de archivos  

Con mÃ©todos como:
- `Files.exists(path)`
- `Files.isReadable(path)`
- `Files.isWritable(path)`
- `Files.isDirectory(path)`

Puedes validar rutas y permisos antes de realizar operaciones, lo cual previene errores y mejora la experiencia del usuario.

ğŸ’¡ Buenas prÃ¡cticas al trabajar con archivos
- Verifica siempre que el archivo exista antes de leerlo o escribir sobre Ã©l.
- Usa rutas relativas para que tu programa sea mÃ¡s portable.
- Aplica `try-catch` y estructuras como `try-with-resources` para cerrar automÃ¡ticamente recursos como archivos abiertos.

ğŸ“Œ Ejemplo:

```java
try (BufferedReader reader = Files.newBufferedReader(path)) {
    String linea;
    while ((linea = reader.readLine()) != null) {
        System.out.println(linea);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```
En resumen, esta sesiÃ³n te permitiÃ³ interactuar de forma **profesional con el sistema de archivos**, manejar documentos de entrada y salida, y escribir cÃ³digo mÃ¡s limpio, seguro y portable. Aprendiste a automatizar tareas comunes como guardar, copiar, mover y validar archivos usando el poder de `Path` y `Files`.

**SesiÃ³n 08. Buenas prÃ¡cticas y manejo de errores en Java**

En esta Ãºltima sesiÃ³n tÃ©cnica, diste un paso importante hacia la *escritura de cÃ³digo profesional*. Aprendiste a identificar problemas de diseÃ±o (code smells), aplicar principios de arquitectura (SOLID) y manejar errores de forma adecuada. Estos conocimientos te preparan para enfrentar proyectos reales con confianza y calidad.

âœ¨ RefactorizaciÃ³n y Code Smells
- Refactorizar es reorganizar tu cÃ³digo sin cambiar su funcionalidad, con el objetivo de hacerlo mÃ¡s legible, modular y mantenible.

- Identificaste code smells comunes:
    - CÃ³digo duplicado
    - Funciones largas o con muchas responsabilidades
    - Nombres poco claros
    - CÃ³digo comentado innecesario

âœ… SoluciÃ³n: renombrar variables, extraer funciones, eliminar redundancias y aplicar el principio de responsabilidad Ãºnica.  

ğŸ§± Principios SOLID
Un conjunto de buenas prÃ¡cticas orientadas a escribir cÃ³digo escalable y fÃ¡cil de modificar:

| Principio                       | DescripciÃ³n                                                                  |
|---------------------------------|------------------------------------------------------------------------------|
| **S** â€“ *Single Responsibility* | Cada clase debe tener una Ãºnica responsabilidad.                             |
| **O** â€“ *Open/Closed*           | El cÃ³digo debe estar abierto a extensiÃ³n, pero cerrado a modificaciÃ³n.       |
| **L** â€“ *Liskov Substitution*   | Las clases hijas deben poder sustituir a las clases padres sin romper la lÃ³gica. |
| **I** â€“ *Interface Segregation* | Las interfaces deben ser especÃ­ficas, no forzar a implementar mÃ©todos innecesarios. |
| **D** â€“ *Dependency Inversion** | Se deben usar abstracciones, no implementaciones concretas.                  |

ğŸ“Œ Aplicarlos mejora la calidad del cÃ³digo y reduce el riesgo de errores al hacer cambios.

âš™ï¸ OptimizaciÃ³n y rendimiento
- Elegir la estructura de datos adecuada: por ejemplo, `HashMap` para bÃºsquedas rÃ¡pidas.
- Dividir funciones largas y evitar bucles innecesarios.
- Reutilizar objetos y evitar asignaciones costosas.
- Cerrar recursos abiertos (archivos, conexiones) para evitar fugas de memoria.

âš ï¸ Manejo de errores con excepciones
- Las excepciones permiten reaccionar ante situaciones inesperadas (divisiones entre cero, archivos inexistentes, errores de entrada...).
- Java las clasifica en:
    - `Checked` (obligatorias de manejar): como `IOException`.
    - `Unchecked` (opcional de manejar): como `NullPointerException`.

ğŸ“Œ Estructura:

```java
try {
    // CÃ³digo que puede fallar
} catch (Exception e) {
    // CÃ³digo de manejo del error
} finally {
    // Siempre se ejecuta
}
```
âœ… `finally` es ideal para liberar recursos (cerrar archivos, conexiones, etc.).  

ğŸš¨ Excepciones personalizadas con `throw` y `throws`  
- `throw`: lanza manualmente una excepciÃ³n.  
- `throws`: declara que un mÃ©todo puede lanzar una excepciÃ³n.  

TambiÃ©n aprendiste a crear tus propias excepciones para manejar reglas de negocio especÃ­ficas:

ğŸ“Œ Ejemplo:

```java
class EdadNoValidaException extends Exception {
    public EdadNoValidaException(String mensaje) {
        super(mensaje);
    }
}
```
Esta sesiÃ³n cerrÃ³ el ciclo tÃ©cnico con herramientas que permiten **escribir cÃ³digo de calidad**: sÃ³lido, eficiente y preparado para lo inesperado. Aprendiste que un buen desarrollador no solo hace que el cÃ³digo funcione, sino que se asegure de que sea claro, seguro y fÃ¡cil de mantener.

---

#### ğŸ“ Cierre

Durante estas nueve sesiones, recorriste un camino completo a travÃ©s de los fundamentos y buenas prÃ¡cticas del desarrollo en Java. 

Desde configurar tu entorno, comprender la programaciÃ³n orientada a objetos, dominar estructuras de control y colecciones, hasta aplicar principios de diseÃ±o, manejar archivos y escribir cÃ³digo robusto frente a errores, **has adquirido una base sÃ³lida para desarrollarte como programador Java**.
Has practicado cÃ³mo escribir cÃ³digo limpio, reutilizable y escalable. Aprendiste no solo a resolver problemas, sino a hacerlo con enfoque estructurado y profesional.

La SesiÃ³n 10 es una oportunidad para consolidar todos estos conocimientos, conectar ideas, identificar temas que requieran reforzamiento y aclarar cualquier duda.

Es un espacio para:
- Reforzar conceptos clave de todas las sesiones.
- Reconocer tu progreso.
- Compartir preguntas, experiencias y aprendizajes con tus compaÃ±eros.
- Prepararte para aplicar todo esto en proyectos reales.

#### ğŸ™Œ Â¡Gracias por llegar hasta aquÃ­!

Este recorrido no solo te enseÃ±Ã³ Java: tambiÃ©n te ayudÃ³ a desarrollar **criterio tÃ©cnico, pensamiento lÃ³gico, disciplina y confianza** en tu proceso de aprendizaje.

AsÃ­ que respira, repasa, reflexiona... Â¡y prepÃ¡rate para cerrar con fuerza este mÃ³dulo! ğŸš€

---

â¬…ï¸ [**Anterior**](../../Sesion-09/Prework/Readme.md)

