üè† [**Inicio**](../../Readme.md) ‚û°Ô∏è / üìñ `Prework sesi√≥n 10`

<div align="center">
    <img src="../Imagenes/S10.jpg" alt="Bedu | Haz + con tu talento | JAVA STANDARD EDITION II">
</div>

##### **PREWORK**
#### **üüß Sesi√≥n 10**
#### **Mentorship 2**

##### üî∂ **Introducci√≥n** 

Llegaste a la meta final de este m√≥dulo de Java Standard Edition II! üéâ

Atr√°s quedaron las primeras l√≠neas de c√≥digo con `System.out.println`, y hoy est√°s a punto de cerrar un ciclo de aprendizaje avanzado, donde cada tema que exploraste te acerc√≥ a construir aplicaciones modernas, robustas y escalables, como las que se usan en empresas reales. üè¢üíª  

A lo largo de estas 8 sesiones, recorriste un camino que comenz√≥ con gestionar datos en bases relacionales, luego te adentraste en el mundo de la concurrencia y la asincron√≠a, aprendiste a procesar flujos de datos de manera funcional y reactiva, construiste microservicios modulares y, finalmente, abrazaste las buenas pr√°cticas que distinguen a los desarrolladores profesionales.  

Cada tema fue como una herramienta nueva que sumaste a tu cintur√≥n de habilidades üß∞. 

Hoy, este prework es el mapa que conecta esas herramientas, mostrando c√≥mo encajan entre s√≠ y c√≥mo puedes aplicarlas juntas en proyectos reales.  

Piensa en esta sesi√≥n como ese momento en el que miras atr√°s y ves todo lo que has construido. üöÄ  

- üîó Bases de datos para guardar la informaci√≥n.
- üßµ Concurrencia y asincron√≠a para que tu app nunca se quede esperando.
- üîÑ Programaci√≥n funcional y reactiva para procesar datos de forma elegante y eficiente.
- üèóÔ∏è Microservicios para que tu sistema sea modular y escalable.
- üß™ Pruebas, logs y control de versiones para asegurar la calidad, estabilidad y colaboraci√≥n en el desarrollo.

Este prework no solo te ayudar√° a repasar cada pieza del rompecabezas, sino tambi√©n a conectar los puntos entre las tecnolog√≠as y buenas pr√°cticas que aprendiste. Porque el conocimiento aislado es √∫til, pero el conocimiento conectado es lo que te permite crear soluciones completas.

---

#### üéØ Objetivo  

- Consolidar el conocimiento adquirido a lo largo de las 8 primeras sesiones de Java SE II, comprendiendo c√≥mo se conectan los conceptos entre s√≠ para construir aplicaciones.  

- Reflexionar sobre la aplicaci√≥n pr√°ctica de herramientas como bases de datos, concurrencia, asincron√≠a, programaci√≥n funcional/reactiva, microservicios y buenas pr√°cticas en el desarrollo de sistemas reales.  

- Prepararse para aplicar este conocimiento en futuros proyectos profesionales, conectando la teor√≠a con las necesidades y retos del mundo real en el desarrollo de software.
---

#### üìã Instrucciones

Este Prework est√° dise√±ado para conocer el contenido que se practicar√° durante la sesi√≥n en vivo. **Por favor no lo omitas**. Toma notas de lo que consideres relevante y guarda tus preguntas o dudas para resolverlas en la sesi√≥n.

---

#### Bienvenido/a

Bienvenid@ al decimo Prework del m√≥dulo. A continuaci√≥n, te presentamos el tiempo estimado de lectura por tema, para que puedas revisar todos los recursos al m√°ximo:

| **üìñ Temario**                       | **üï∞Ô∏è Tiempo sugerido** |
|--------------------------------------|-------------------------|
| Tema 01. Repaso integral del modulo  | 15 min                  |

**¬°Comencemos! üèÅ**

---
¬†
#### üìö Tema 01. Repaso integral del modulo
##### ‚è≥ 15 minutos de lectura.

Este es el momento de hacer una pausa y mirar en conjunto todo lo que aprendiste en Java SE II. No se trata solo de recordar, sino de entender c√≥mo cada tema aporta a la construcci√≥n de sistemas modernos.

En este repaso, conectar√°s las piezas clave: bases de datos, concurrencia, asincron√≠a, programaci√≥n funcional y reactiva, microservicios y buenas pr√°cticas.

Un cierre para reforzar lo que ya dominas y prepararte para los pr√≥ximos retos. üöÄ üí™üöÄ

**Sesi√≥n 01. Gesti√≥n de bases de datos**

En esta sesi√≥n, aprendiste a conectar Java con bases de datos usando JPA, Hibernate y Spring Boot, facilitando el acceso y manipulaci√≥n de datos sin escribir SQL manualmente. Configuraste una base embebida H2 y expusiste endpoints REST para consultar y gestionar informaci√≥n, sentando las bases para construir aplicaciones backend modernas.

üóÑÔ∏è Introducci√≥n a la conexi√≥n de bases de datos en Java
- Aprendiste las dos principales formas en las que una aplicaci√≥n Java puede conectarse a una base de datos:
    - JDBC (Java Database Connectivity): El modelo tradicional donde necesitas escribir consultas SQL manualmente y gestionar las conexiones de forma expl√≠cita.
    - JPA + Hibernate (ORM): El modelo moderno que permite mapear clases Java directamente a tablas, eliminando la necesidad de escribir SQL en muchas operaciones y facilitando el trabajo con bases de datos desde un enfoque orientado a objetos.

Conociste los conceptos clave de entidad, repositorio y persistencia, esenciales para automatizar las operaciones CRUD (Crear, Leer, Actualizar, Eliminar) en las bases de datos.

‚öôÔ∏è Configuraci√≥n de base de datos y entorno de desarrollo
- Configuraste un entorno de trabajo completo para desarrollar aplicaciones conectadas a bases de datos, utilizando:
    - H2 Database: Una base embebida, ideal para pruebas r√°pidas, sin necesidad de instalar un sistema de bases de datos externo.
    - Maven: El gestor de dependencias que facilita la integraci√≥n de librer√≠as como Spring Boot Starter Data JPA y H2.
    - Archivo `application.properties`: Donde definiste la configuraci√≥n de la conexi√≥n a la base de datos, como la URL, el driver, las credenciales y el comportamiento de Hibernate (ddl-auto=update), permitiendo que las tablas se creen o actualicen autom√°ticamente.

Esta configuraci√≥n te permiti√≥ tener una base de datos lista para usar en minutos, enfoc√°ndote en el desarrollo sin complicaciones t√©cnicas.

üåê Conexi√≥n a una base de datos desde una aplicaci√≥n web
- Construiste un flujo completo de persistencia y consulta de datos usando Spring Boot, estructurando la aplicaci√≥n en capas:
    - Entidad: Define la estructura de los datos.
    - Repositorio: Facilita operaciones CRUD sin escribir SQL.
    - Servicio: Contiene la l√≥gica de negocio para manejar los datos.
    - Controlador: Expone la API mediante endpoints REST, permitiendo interactuar con la base de datos desde el navegador o Postman.

Finalmente, probaste el endpoint `/estudiantes` con Postman, comprobando que tu aplicaci√≥n pod√≠a consultar y devolver datos en formato JSON, cerrando el ciclo desde la base de datos hasta la interfaz de prueba.

> Esta sesi√≥n fue el punto de partida para conectar Java con bases de datos de forma profesional, entendiendo c√≥mo estructurar aplicaciones y automatizar operaciones CRUD. Con estas bases, abriste la puerta al desarrollo de sistemas robustos y escalables.

---

**Sesi√≥n 02: Multihilos y procesos concurrentes**  

Aprendiste a ejecutar m√∫ltiples tareas simult√°neas en Java mediante hilos y concurrencia, combinando t√©cnicas b√°sicas (`Thread`, `Runnable`) y avanzadas (`ExecutorService`, `Callable`, `Future`). Adem√°s, conociste c√≥mo evitar errores en el acceso a recursos compartidos usando mecanismos de sincronizaci√≥n.

üîÑ Introducci√≥n a la concurrencia
- Comprendiste qu√© es la concurrencia: la capacidad de una aplicaci√≥n para manejar m√∫ltiples tareas al mismo tiempo (o de forma intercalada).  

- Conociste los conceptos clave:
    - Proceso: Programa en ejecuci√≥n con su propio espacio de memoria.
    - Hilo (Thread): Subunidad dentro de un proceso que permite ejecutar tareas simult√°neamente.

- Aprendiste el ciclo de vida de un hilo (`New ‚Üí Runnable ‚Üí Running ‚Üí Blocked ‚Üí Dead`) y los m√©todos esenciales:
    - `start()`: Inicia un hilo.
    - `run()`: Define la tarea que ejecuta el hilo.
    - `sleep()`: Pausa temporalmente un hilo.
    - `join()`: Hace que un hilo espere a otro antes de continuar.

Estos conceptos sentaron las bases para comprender c√≥mo las tareas concurrentes mejoran la respuesta de las aplicaciones.

‚öôÔ∏è Creaci√≥n de hilos en Java
- Viste las formas b√°sicas de crear hilos:
    - Clase `Thread`: Extendiendo la clase y sobreescribiendo el m√©todo `run()`.
    - Interfaz `Runnable`: Definiendo la tarea como una expresi√≥n lambda, ideal para programaci√≥n funcional.

- ExecutorService y Callable:
    - Aprendiste a manejar pools de hilos con ExecutorService, evitando la creaci√≥n manual de hilos.
    - Usaste Callable para lanzar tareas que devuelven resultados y Future para obtener esos resultados en el futuro.

Ejemplo de uso:

```java
ExecutorService executor = Executors.newFixedThreadPool(2);
Callable<Integer> tarea = () -> 42;
Future<Integer> resultado = executor.submit(tarea);
System.out.println(resultado.get());  // Devuelve 42
```

Este tema te permiti√≥ organizar mejor la ejecuci√≥n de m√∫ltiples tareas, con herramientas modernas que facilitan la gesti√≥n de hilos y resultados.

üîê Sincronizaci√≥n de hilos
- Aprendiste sobre condiciones de carrera, que ocurren cuando varios hilos acceden al mismo recurso al mismo tiempo, provocando resultados impredecibles.
- Conociste el uso de synchronized para proteger secciones cr√≠ticas del c√≥digo, garantizando que solo un hilo a la vez acceda a determinados bloques o m√©todos.

Ejemplo:

```java
public synchronized void incrementar() {
    valor++;
}
```
Exploraste mecanismos de control m√°s avanzados:
- Locks y ReentrantLock: Alternativas a synchronized que ofrecen mayor control.
- `wait()` y `notify()`: Permiten que un hilo espere y otro lo despierte, facilitando la comunicaci√≥n entre hilos (patrones como productor-consumidor).

Este tema te prepar√≥ para controlar el acceso concurrente a los recursos compartidos, evitando errores aleatorios y bloqueos.

> Ahora dominas las herramientas para gestionar procesos paralelos y controlar el acceso a los recursos, permitiendo desarrollar aplicaciones que responden mejor ante m√∫ltiples tareas simult√°neas.

---

**Sesi√≥n 03. Programaci√≥n funcional**

Aprendiste a aplicar principios de la programaci√≥n funcional en Java para escribir c√≥digo m√°s claro, predecible y expresivo. Usaste funciones puras, lambdas, interfaces funcionales y Optional para mejorar la gesti√≥n de valores nulos. Tambi√©n trabajaste con la Stream API para transformar y procesar colecciones de manera fluida, y conociste c√≥mo componer funciones para crear procesos m√°s complejos y reutilizables.  

üß† Fundamentos del paradigma funcional  
- Conociste qu√© es una funci√≥n pura: aquella que devuelve siempre el mismo resultado si recibe los mismos argumentos y no genera efectos secundarios.  
- Exploraste conceptos clave:  
    - Estado inmutable: los datos no cambian, sino que se crean nuevas versiones.  
    - Interfaz funcional: una interfaz con un solo m√©todo abstracto (ej. `Predicate`, `Function`, `Consumer`).  

- Usaste lambdas y referencias a m√©todos para definir funciones de forma compacta y flexible. Ejemplo de lambda:  

```java
nombres.forEach(nombre -> System.out.println(nombre));
```

üõ°Ô∏è Optional y Streams b√°sicos  
- Aplicaste Optional como alternativa para evitar errores por valores nulos (`NullPointerException`), asegurando que los valores se manejen de forma segura:  

```java
Optional<String> nombre = Optional.ofNullable(obtenerNombre());
nombre.ifPresent(n -> System.out.println(n.toUpperCase()));
```

- Procesaste listas usando la Stream API, encadenando operaciones como `filter`, `map`, y `forEach` para transformar colecciones sin escribir bucles. Ejemplo con Stream:  

```java
nombres.stream()
       .filter(nombre -> nombre.length() > 3)
       .map(String::toUpperCase)
       .forEach(System.out::println);
```

üîó Composici√≥n funcional en Java  
- Aprendiste a encadenar funciones usando `andThen()` y `compose()` para construir procesos complejos a partir de funciones simples. Ejemplo:  

```java
Function<Integer, Integer> multiplicarPor2 = x -> x * 2;
Function<Integer, Integer> sumar3 = x -> x + 3;

Function<Integer, Integer> combinado = multiplicarPor2.andThen(sumar3);
System.out.println(combinado.apply(5));  // Resultado: 13
```

Usaste `flatMap` para transformar estructuras anidadas, como listas de listas, en un solo flujo de datos:  

```java
listas.stream()
     .flatMap(Collection::stream)
     .forEach(System.out::println);
```

> Incorporaste una forma diferente de escribir c√≥digo, enfocada en transformar datos de manera fluida y segura, mejorando la legibilidad y reduciendo errores. Aprendiste a pensar en funciones como piezas reutilizables que se combinan para crear procesos claros y ordenados.    

---

**Sesi√≥n 04. Procesos as√≠ncronos**  
Aprendiste a manejar tareas que tardan sin detener el flujo de ejecuci√≥n, aplicando asincron√≠a para que las aplicaciones puedan seguir funcionando mientras esperan respuestas externas o completan operaciones largas. Usaste `CompletableFuture` para lanzar y encadenar procesos en segundo plano, manejar errores de manera fluida y combinar tareas, mejorando la experiencia y respuesta de los sistemas.  

‚ö° Asincron√≠a vs concurrencia  
- Diferencias clave:  
    - Concurrencia: Ejecutar varias tareas al mismo tiempo, turn√°ndose o en hilos separados.  
    - Asincron√≠a: Lanzar una tarea, seguir trabajando y recoger el resultado despu√©s, sin bloquear el flujo.  

- Conociste conceptos como:  
    - Latencia: Tiempo que tarda una operaci√≥n en completarse.
    - Tareas bloqueantes vs no bloqueantes:  
        - Bloqueante ‚Üí el sistema espera a que la tarea termine.  
        - No bloqueante ‚Üí el sistema sigue ejecutando otras acciones mientras espera.  

- Identificaste cu√°ndo usar hilos (concurrencia), asincron√≠a, o una combinaci√≥n de ambos, dependiendo del tipo de operaci√≥n (ej. m√∫ltiples usuarios vs llamadas a servicios externos).  

üîó Uso de `CompletableFuture`  
- Implementaste tareas as√≠ncronas con `CompletableFuture`, permitiendo lanzar procesos en segundo plano sin detener la aplicaci√≥n.  

- Aprendiste a encadenar acciones con m√©todos como:  

    - `thenApply()`: Transforma el resultado.  
    - `thenAccept()`: Consume el resultado.  
    - `thenCompose()`: Encadena otra tarea as√≠ncrona.  

- Manejaste errores de forma elegante usando `exceptionally`, asegurando que las fallas no detengan el flujo de la aplicaci√≥n.  

üåê Aplicaciones pr√°cticas  
- Aplicaste asincron√≠a en operaciones I/O:  
    - Simulaste escritura de archivos y consultas a servicios externos sin bloquear el hilo principal.  

- Usaste combinaciones de tareas (`thenCombine`) para coordinar m√∫ltiples procesos en paralelo y combinar sus resultados cuando ambas tareas terminan.  
- Conociste buenas pr√°cticas:  
    - Usar asincron√≠a en tareas lentas o externas.  
    - Controlar el n√∫mero de tareas para no saturar recursos.  
    - Manejar timeouts y errores en todas las operaciones.  


> Integraste asincron√≠a en tus procesos, permitiendo que las aplicaciones sigan respondiendo mientras completan tareas complejas en segundo plano, mejorando la fluidez y respuesta del sistema.  

---

**Sesi√≥n 05.  Stream Reactivos**  

Aprendiste a procesar flujos de datos continuos de forma as√≠ncrona y no bloqueante usando programaci√≥n reactiva. Conociste los conceptos de Mono y Flux para manejar uno o muchos elementos, exploraste c√≥mo transformar esos flujos con operadores como `map`, `flatMap`, `filter`, y aplicaste backpressure para evitar que el sistema se sature cuando llegan grandes vol√∫menes de datos  

üîÑ Introducci√≥n a programaci√≥n reactiva  

- Entendiste la diferencia entre Streams tradicionales y programaci√≥n reactiva:  
    - Stream tradicional ‚Üí Procesa colecciones finitas de forma sincr√≥nica.  
    - Programaci√≥n reactiva ‚Üí Procesa flujos continuos o infinitos de datos de manera as√≠ncrona y no bloqueante.  
- Conociste los principios del Reactive Manifesto:  
    - Responsivo, resiliente, el√°stico, orientado a mensajes.  
- Ejemplo clave:  
    - Stream tradicional procesa una lista completa.  
    - Flux (reactivo) procesa eventos que llegan en tiempo real (usuarios conectados, mensajes, sensores).  

‚öôÔ∏è Project Reactor / RxJava  
- Usaste Project Reactor (integrado en Spring) y RxJava para crear flujos reactivos.  
- Mono:  
    - Flujos que emiten 0 o 1 valor.  
    - √ötil para respuestas √∫nicas (ej. una consulta a una API).  

- Flux:  
    - Flujos que emiten 0, 1 o muchos valores (potencialmente infinitos).  
    - √ötil para manejar eventos continuos (mensajes, sensores, usuarios conectados).  

- Aplicaste operadores:  
    - `map`, `filter`: Transforman o filtran datos.  
    - `flatMap`: Combina flujos de datos.  

- Ejemplo clave:  
    - Flux.just(1,2,3) ‚Üí procesa cada elemento de forma fluida.  

üõ°Ô∏è Manejo avanzado de flujos  
- Implementaste backpressure para regular la velocidad del flujo de datos:
    - `limitRate(n)`: Procesa solo n elementos a la vez.  
    - `onBackpressureBuffer()`: Almacena datos si el consumidor va m√°s lento.  
    - `onBackpressureDrop()`: Descarta datos que no alcanzan a procesarse.  

- Conociste el encadenamiento de operaciones para transformar flujos de forma ordenada y fluida.  

- Aplicaciones reales:  
    - Microservicios que manejan m√∫ltiples solicitudes.  
    - Sistemas de mensajer√≠a (Kafka, RabbitMQ).  
    - Monitoreo de sensores (IoT).  
    - Streams de video, chat, juegos en l√≠nea.  


> Aprendiste a procesar datos continuos y as√≠ncronos con control sobre el flujo, manteniendo las aplicaciones adaptables ante picos de carga. Usaste Mono y Flux para manejar diferentes tipos de flujos y aplicaste backpressure para asegurar que el sistema responda fluidamente, sin saturarse.  

---

**Sesi√≥n 06. Clases gen√©ricas**

Exploraste c√≥mo escribir c√≥digo flexible y seguro usando gen√©ricos en Java, permitiendo que clases, m√©todos y estructuras funcionen con diferentes tipos de datos sin duplicar c√≥digo. Aplicaste wildcards (`?`, `extends`, `super`) para ampliar o limitar esa flexibilidad, y conociste c√≥mo dise√±ar componentes reutilizables que mantienen la seguridad en tiempo de compilaci√≥n.  

üì¶ Introducci√≥n a los gen√©ricos en Java  
- Comprendiste qu√© son los gen√©ricos: estructuras que permiten trabajar con cualquier tipo de dato, sin perder seguridad de tipos.  
- Sintaxis clave:  
    - `<T>`, `<E>`, `<K, V>` ‚Üí par√°metros gen√©ricos para representar tipos flexibles.  

- Ejemplo simple de clase gen√©rica:  

```java
public class Caja<T> {
    private T contenido;
    public void guardar(T contenido) { this.contenido = contenido; }
    public T obtener() { return contenido; }
}
```

- Ventajas:  
    - Evitas casting manual.  
    - Seguridad en compilaci√≥n (detectas errores antes de ejecutar).  
    - Reutilizaci√≥n de c√≥digo para diferentes tipos.  

üîó Wildcards y restricciones  
Conociste los wildcards (`?`) para ampliar la flexibilidad en colecciones:  


| Wildcard	       | ¬øQu√© permite?        | Ejemplo|
|------------------|----------------------|---------|
| `?`              | Cualquier tipo	      | `List<?>` | 
| `? extends Tipo` | Subtipos de un tipo  | `List<? extends Number>` | 
| `? super Tipo`   | Supertipos de un tipo | `List<? super Integer>` | 

- Uso pr√°ctico:  
    - `? extends` ‚Üí Cuando solo necesitas leer datos.  
    - `? super` ‚Üí Cuando necesitas agregar datos.  

- Aplicaste restricciones en gen√©ricos para limitar qu√© tipos se aceptan:  

```java
public class CajaNumeros<T extends Number> { ... }
```
Esto garantiza que solo se usen tipos num√©ricos (como Integer, Double).  

üõ†Ô∏è Aplicaciones comunes
- Aplicaste gen√©ricos para evitar castings y mejorar la seguridad del c√≥digo:  

```java
List<String> lista = new ArrayList<>();
```

- Dise√±aste clases reutilizables (como repositorios, validadores) que funcionan para diferentes tipos de datos:  

```java
public class Repositorio<T> { ... }
```

- Usaste restricciones de tipos (`<T extends Number>`) para asegurar que ciertos componentes solo acepten tipos compatibles.  

- Aplicaciones reales:  
    - Repositorios en microservicios para manejar distintas entidades.  
    - Validadores gen√©ricos para listas o entradas.  
    - Colecciones en APIs (ej. `List<Producto>`).  

> Aplicaste gen√©ricos para dise√±ar componentes flexibles y seguros, evitando duplicar c√≥digo y asegurando que los tipos se validen en tiempo de compilaci√≥n. Conociste wildcards para ajustar la flexibilidad seg√∫n el contexto, facilitando la reutilizaci√≥n y adaptabilidad del c√≥digo en proyectos de cualquier tama√±o.  

---

**Sesi√≥n 07. Microservicios**

Descubriste c√≥mo dividir un sistema grande en servicios peque√±os, independientes y especializados, entendiendo las diferencias entre arquitectura monol√≠tica y microservicios. Aprendiste a crear una API REST b√°sica usando Spring Boot, y exploraste las formas en que los microservicios se comunican entre s√≠ de manera s√≠ncrona (REST) y as√≠ncrona (mensajer√≠a).  


üß© Arquitectura de microservicios  
- Entendiste qu√© es un microservicio: un m√≥dulo independiente con su propia l√≥gica y, opcionalmente, su propia base de datos.  
- Comparaste monolitos vs microservicios:  
    - Monolito: Todo est√° conectado y despliegas el sistema completo.  
    - Microservicios: Cada servicio puede actualizarse, escalarse o fallar de manera aislada.  

- Ventajas:
    - Despliegue independiente.  
    - Escalabilidad granular.  
    - Mejor tolerancia a fallos.  
    - Flexibilidad tecnol√≥gica.  

- Desventajas:  
    - Complejidad en la comunicaci√≥n.  
    - Mayor esfuerzo operativo.  
    - Sincronizaci√≥n de datos entre servicios.  

- Casos de √©xito: Netflix, Amazon y Spotify usan microservicios para manejar sistemas altamente din√°micos y de gran volumen.  

‚öôÔ∏è Introducci√≥n a Spring Boot  
- Conociste Spring Boot como el framework que simplifica el desarrollo de APIs REST en Java:  
    - Configuraci√≥n autom√°tica.  
    - Servidor embebido listo para usarse (Tomcat, Jetty).  
    - Starters: paquetes preconfigurados para conectar bases de datos, exponer servicios web, manejar seguridad, etc.  

- Creaste un servicio web sencillo en minutos usando:  
    - Dependencias en Maven (`spring-boot-starter-web`).  
    - Anotaciones como `@SpringBootApplication` y `@RestController`.  
    - Servidor embebido ejecut√°ndose directamente al iniciar el proyecto.  

- Aplicaci√≥n pr√°ctica:  
    - Cada microservicio puede ser un proyecto Spring Boot independiente, corriendo en diferentes puertos.  

üîó Comunicaci√≥n entre servicios  
- Comunicaci√≥n s√≠ncrona (REST):  
    - Un servicio realiza una solicitud HTTP (GET, POST) y espera una respuesta inmediata.  
    - Uso t√≠pico: Validar pagos, verificar stock.  

- Comunicaci√≥n as√≠ncrona (mensajer√≠a):  
    - Un servicio env√≠a un mensaje a una cola (RabbitMQ, Kafka) y otro servicio lo procesa cuando puede.  
    - Uso t√≠pico: Registro de logs, env√≠o de correos, procesamiento de eventos.  

- Herramientas pr√°cticas:  
    - RestTemplate para llamadas HTTP entre microservicios.  
    - Alternativas modernas: WebClient, FeignClient.  

- Decidir entre REST o mensajer√≠a depende de si necesitas respuesta inmediata o puedes procesar en segundo plano.  

> Comprendiste c√≥mo modularizar aplicaciones complejas mediante microservicios, utilizando Spring Boot para construir APIs independientes y explorando diferentes formas de comunicaci√≥n para mantener la colaboraci√≥n entre servicios de manera fluida y adaptable a distintos escenarios.  

---

**Sesi√≥n 08. Buenas pr√°cticas y manejo de errores en Java**  

Aprendiste a aplicar convenciones de dise√±o, pruebas unitarias, depuraci√≥n y control de versiones para construir proyectos de mayor calidad, organizaci√≥n y mantenibilidad. Conociste herramientas como JUnit 5, Mockito, SLF4J y Git, y entendiste la importancia de escribir c√≥digo que no solo funcione, sino que sea legible, probado y controlado.  

üßπ Principios de dise√±o en Java  
- Entendiste que un buen dise√±o no solo hace que el c√≥digo funcione, sino que sea comprensible y sostenible a largo plazo.  
- Aplicaste:  
    - Convenciones de c√≥digo (nombres de clases, m√©todos, variables y constantes).  
    - Refactorizaci√≥n: Mejorar la estructura interna del c√≥digo sin cambiar su funcionalidad.  
    - Patrones de dise√±o (ej. Singleton) para resolver problemas comunes de forma estructurada.  
- Reflexionaste sobre c√≥mo refactorizar continuamente y adoptar patrones evita que el c√≥digo se vuelva dif√≠cil de mantener.  

üß™ Pruebas unitarias y depuraci√≥n  
- Implementaste pruebas unitarias con JUnit 5:  
    - Validaci√≥n de excepciones.  
    - Pruebas parametrizadas para reducir duplicaci√≥n de c√≥digo.  

- Usaste Mockito para crear mocks que permiten probar componentes de forma aislada, simulando sus dependencias.  
- Aplicaste buenas pr√°cticas de logging con SLF4J, entendiendo:  
    - La importancia de niveles de logs (`debug`, `info`, `warn`, `error`).  
    - C√≥mo agregar contexto relevante para facilitar la depuraci√≥n.  
- Conectaste la importancia de automatizar las pruebas y registrar eventos de ejecuci√≥n para mejorar la detecci√≥n de errores en todas las fases del desarrollo.  

üîó Organizaci√≥n del c√≥digo y control de versiones  
- Aprendiste a organizar proyectos Java siguiendo una estructura por capas:
    - controller, service, repository, model.  

- Implementaste buenas pr√°cticas de Git:  
    - Crear ramas para nuevas funcionalidades.  
    - Hacer commits peque√±os y descriptivos.  
    - Usar Pull Requests para revisi√≥n de cambios.  
    - Mantener un flujo limpio y ordenado de integraci√≥n de c√≥digo.  

- Entendiste c√≥mo un buen uso de Git facilita el trabajo en equipo y permite manejar proyectos de cualquier tama√±o sin caos.  

> Incorporaste pr√°cticas esenciales para que tus proyectos sean m√°s claros, probados y organizados, facilitando su crecimiento y colaboraci√≥n en equipos. Aprendiste a integrar dise√±o, pruebas, logs y control de versiones como parte natural de tu flujo de desarrollo.  

---

#### üìù Cierre  

¬°Felicidades por completar este recorrido en Java SE II! üèÅ  

A lo largo de estas sesiones, expandiste tu conocimiento en √°reas clave:
üóÑÔ∏è Bases de datos, üîÑ Procesos concurrentes, üß© Programaci√≥n funcional, üåê Programaci√≥n reactiva, üõ†Ô∏è Microservicios, üß™ Pruebas unitarias y üìù Control de versiones.  

Cada tema representa una nueva herramienta en tu kit profesional üß∞, fortaleciendo tu capacidad para construir aplicaciones claras, seguras y bien estructuradas.  

#### üéØ Gracias por tu tiempo, dedicaci√≥n y apertura al aprendizaje.  

Cada esfuerzo que realizaste demuestra tu compromiso y tu visi√≥n de crecimiento en el mundo del desarrollo de software. üôå  

Valoramos profundamente tu disposici√≥n para **aprender, practicar y conectar ideas**. üí°  
Avanzaste en tu camino profesional con paso firme, enfrentando nuevos conceptos y plasm√°ndolos en proyectos reales.  

üéì ¬°Hoy celebramos el conocimiento que construiste!  

Cada l√≠nea de c√≥digo, cada prueba ejecutada y cada microservicio dise√±ado es una evidencia tangible de tu avance. üìà‚ú®  

As√≠ que respira, repasa, reflexiona... ¬°y prep√°rate para cerrar con fuerza este m√≥dulo! üöÄ  

---

‚¨ÖÔ∏è [**Anterior**](../../Sesion-09/Prework/Readme.md)

